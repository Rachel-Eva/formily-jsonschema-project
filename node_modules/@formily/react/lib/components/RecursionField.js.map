{"version":3,"file":"RecursionField.js","sourceRoot":"","sources":["../../src/components/RecursionField.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { Fragment, useMemo } from 'react'\nimport { FormPath, isBool, isFn, isValid } from '@formily/shared'\nimport { GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { SchemaContext } from '../shared'\nimport { IRecursionFieldProps, ReactFC } from '../types'\nimport { useField, useExpressionScope } from '../hooks'\nimport { ObjectField } from './ObjectField'\nimport { ArrayField } from './ArrayField'\nimport { Field } from './Field'\nimport { VoidField } from './VoidField'\nimport { ExpressionScope } from './ExpressionScope'\nimport { observable } from '@formily/reactive'\n\nconst useFieldProps = (schema: Schema) => {\n  const scope = useExpressionScope()\n  return schema.toFieldProps({\n    scope,\n  }) as any\n}\n\nconst useBasePath = (props: IRecursionFieldProps) => {\n  const parent = useField()\n  if (props.onlyRenderProperties) {\n    return props.basePath || parent?.address.concat(props.name)\n  }\n  return props.basePath || parent?.address\n}\n\nexport const RecursionField: ReactFC<IRecursionFieldProps> = (props) => {\n  const basePath = useBasePath(props)\n  const fieldSchema = useMemo(() => new Schema(props.schema), [props.schema])\n  const fieldProps = useFieldProps(fieldSchema)\n\n  const renderSlots = (innerSchema, key) => {\n    const slot = innerSchema['x-slot-node']\n    const { target, isRenderProp } = slot\n    if (isRenderProp) {\n      const args = observable({ $slotArgs: [] })\n      FormPath.setIn(fieldSchema.properties, target, (..._args: any) => {\n        args.$slotArgs = _args\n        return (\n          <ExpressionScope value={args}>\n            <RecursionField schema={innerSchema} name={key} />\n          </ExpressionScope>\n        )\n      })\n    } else {\n      FormPath.setIn(\n        fieldSchema.properties,\n        target,\n        <RecursionField schema={innerSchema} name={key} />\n      )\n    }\n  }\n\n  const renderProperties = (field?: GeneralField) => {\n    if (props.onlyRenderSelf) return\n    const properties = Schema.getOrderProperties(fieldSchema)\n    if (!properties.length) return\n    return (\n      <Fragment>\n        {properties.map(({ schema: item, key: name }, index) => {\n          const base = field?.address || basePath\n          let schema: Schema = item\n          if (schema['x-slot-node']) {\n            renderSlots(schema, name)\n            return null\n          }\n\n          if (isFn(props.mapProperties)) {\n            const mapped = props.mapProperties(item, name)\n            if (mapped) {\n              schema = mapped\n            }\n          }\n          if (isFn(props.filterProperties)) {\n            if (props.filterProperties(schema, name) === false) {\n              return null\n            }\n          }\n          if (isBool(props.propsRecursion) && props.propsRecursion) {\n            return (\n              <RecursionField\n                propsRecursion={true}\n                filterProperties={props.filterProperties}\n                mapProperties={props.mapProperties}\n                schema={schema}\n                key={`${index}-${name}`}\n                name={name}\n                basePath={base}\n              />\n            )\n          }\n          return (\n            <RecursionField\n              schema={schema}\n              key={`${index}-${name}`}\n              name={name}\n              basePath={base}\n            />\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  const render = () => {\n    if (!isValid(props.name)) return renderProperties()\n    if (fieldSchema.type === 'object') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <ObjectField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </ObjectField>\n      )\n    } else if (fieldSchema.type === 'array') {\n      return (\n        <ArrayField {...fieldProps} name={props.name} basePath={basePath} />\n      )\n    } else if (fieldSchema.type === 'void') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <VoidField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </VoidField>\n      )\n    }\n    return <Field {...fieldProps} name={props.name} basePath={basePath} />\n  }\n\n  if (!fieldSchema) return <Fragment />\n\n  return (\n    <SchemaContext.Provider value={fieldSchema}>\n      {render()}\n    </SchemaContext.Provider>\n  )\n}\n"]}